/*************************************************************
 *                                                           *
 * Assembly Guidance Systems new laser device tests          *
 * Copyright 2015.                                           *
 *                                                           *
 * Test Name:  lv_box_tests                                  *
 * Command  :  "lv_box_tests"                                *
 * Input    :    startX, startY, step, count.                *
 * Description:  This test exercises the new kernel laser    *
 *               device driver.  It attempts to do a line    *
 *               along X axis, line along Y axis, then       *
 *               sense on X & Y lines.                       *
 *                                                           *
 ************************************************************/
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <stddef.h>
#include <errno.h>
#include <sys/io.h>
#include <math.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/tcp.h>
#include <linux/laser_api.h>
#include <string.h>
#include "BoardComm.h"
#include "Laser_If.h"

// Some people don't know how to use structs so following globals are here
// just to get things compiling for test code.
// CODE REVIEWS & DATA STRUCTURE COURSE WOULD GO A LONG WAY

int gVideoCount = 0;
int gVideoCheck = 0;

struct lg_master *pConfigMaster=0;

static void do_write_dark_xydata(int16_t x, int16_t y)
{
    struct lv2_xypoints   xydata;

    xydata.xPoint = x;
    xydata.yPoint = y;
    lv_setpoints_dark(pConfigMaster, &xydata);
    return;
}
static void do_write_xydata(int16_t x, int16_t y)
{
    struct lv2_xypoints   xydata;

    xydata.xPoint = x;
    xydata.yPoint = y;
    lv_setpoints_lite(pConfigMaster, &xydata);
    return;
}
static void do_write_sensedata_x(int16_t point, uint16_t step, uint16_t loop_count)
{
    struct lv2_sense_info   sense_data;

    sense_data.data = point;
    sense_data.step = step;
    sense_data.loop_count = loop_count;

    lv_senseX_cmd(pConfigMaster, (struct lv2_sense_info *)&sense_data);
    return;
}
static void do_write_sensedata_y(int16_t point, uint16_t step, uint16_t loop_count)
{
    struct lv2_sense_info   sense_data;

    sense_data.data = point;
    sense_data.step = step;
    sense_data.loop_count = loop_count;

    lv_senseY_cmd(pConfigMaster, (struct lv2_sense_info *)&sense_data);
    return;
}
static void do_write_sense_one_x(int16_t point, uint32_t index)
{
    struct lv2_sense_one_info   sense_data;

    sense_data.data = point;
    sense_data.index = index;
    lv_sense_oneX_cmd(pConfigMaster, (struct lv2_sense_one_info *)&sense_data);
    return;
}    
static void do_write_sense_one_y(int16_t point, uint32_t index)
{
    struct lv2_sense_one_info   sense_data;

    sense_data.data = point;
    sense_data.index = index;
    lv_sense_oneY_cmd(pConfigMaster, (struct lv2_sense_one_info *)&sense_data);
    return;
}    
int main( int argc, char ** argv )
{
    struct write_sense_data   *pWriteSenseData;
    int                        error;
    int16_t                    i;
    int16_t                    inputX;
    int16_t                    inputY;
    uint16_t                   step;
    uint16_t                   data_size;
    uint16_t                   loop_count;
    
    // Make sure user entered x & y coords
    if(argc < 5)
      {
	printf("Syntax: box_test <x> <y> <step>\n");
	exit(EXIT_FAILURE);
      }

    // Get input data
    inputX = atoi(argv[1]);
    inputY = atoi(argv[2]);
    step = atoi(argv[3]);
    loop_count = atoi(argv[4]);
    
    openlog("agsd", 0, LOG_USER);
    syslog(LOG_NOTICE, "CoarseScan Box Test");

    pConfigMaster = malloc(sizeof(struct lg_master));
    if (!pConfigMaster)
      {
	syslog(LOG_ERR, "LG_MASTER_MALLOC Failed\n");
	closelog();
	exit(EXIT_FAILURE);
      }
    memset((char *)pConfigMaster, 0, sizeof(struct lg_master));
    pConfigMaster->fd_lv2 = open("/dev/lv2", O_RDWR);
    if (pConfigMaster->fd_lv2 < 0)
      {
	syslog(LOG_ERR,"laser device %d not opened,errno %d", pConfigMaster->fd_lv2, errno);
	free(pConfigMaster);
	closelog();
	exit(EXIT_FAILURE);
      }
    data_size = loop_count  * sizeof(struct write_sense_data);
    pWriteSenseData = (struct write_sense_data *)malloc(data_size);
    if (!pWriteSenseData)
      syslog(LOG_ERR,"\nCoarseScanFindMatch: ERROR trying to malloc buffer\n");

    // Try to write X points
    do_write_dark_xydata(inputX,inputY);
    usleep(100);
    for (i = inputX; i < 10000+inputX; i+=step)
      {
	do_write_xydata(i, inputY);
	usleep(1 * 1000);
      }
    syslog(LOG_NOTICE, "X Line Test Complete: StartX=%x, StartY=%x, Step=%d\n", inputX,inputY, step);
    usleep(300 * 1000);
    do_write_dark_xydata(inputX+10000,inputY);

    // Now traverse Y
    do_write_dark_xydata(inputX,inputY);
    for (i = inputY; i < inputY+10000; i+=step)
      {
	do_write_xydata(0, inputY + i);
	usleep(1 * 1000);
      }
    syslog(LOG_NOTICE, "Y Line Test Complete:  StartX=%x, StartY=%x, Step=%d\n", inputX,inputY, step);
    do_write_dark_xydata(inputX,inputY+10000);
    do_write_dark_xydata(inputX,inputY);

    usleep(1000 * 1000);
    // Sense-X (loop in driver) unit test
    syslog(LOG_NOTICE, "Start Sense-Traverse-X unit test");
    do_write_dark_xydata(inputX,inputY);
    do_write_sensedata_x(inputX, step, loop_count);
    error = read(pConfigMaster->fd_lv2, (uint8_t *)pWriteSenseData, data_size);
    if (error < 0)
      {
	syslog(LOG_ERR,"\nError reading from LV2 device\n");
	free((uint8_t *)pWriteSenseData);
	exit(EXIT_FAILURE);
      }
    // Display data
    syslog(LOG_NOTICE,"sense_data for Xtraverse:");
    for (i = 0; i < loop_count; i++)
      {
	syslog(LOG_NOTICE,"   xpoint[%d]=%x;sense_data=%x",
	       i,pWriteSenseData[i].point, pWriteSenseData[i].sense_val);
      }
    usleep(1000 * 1000);
    // Sense-Y (loop in driver) unit test
    do_write_dark_xydata(inputX,inputY);
    do_write_sensedata_y(inputY, step, loop_count);
    error = read(pConfigMaster->fd_lv2, (uint8_t *)pWriteSenseData, data_size);
    if (error < 0)
      {
	syslog(LOG_ERR,"\nError reading from LV2 device\n");
	free((uint8_t *)pWriteSenseData);
	exit(EXIT_FAILURE);
      }
    // Display data
    syslog(LOG_NOTICE, "BOX_TEST:  sense_data for Ytraverse(driver-loop):");
    for (i = 0; i < loop_count; i++)
      {
	syslog(LOG_NOTICE,"   ypoint[%d]=%x;sense_data=%x",
	       i,pWriteSenseData[i].point, pWriteSenseData[i].sense_val);
      }
    // Sense-X (loop here), driver does single point sense-operation
    for (i = 0; i < loop_count; i++)
      {
	do_write_sense_one_x(inputX+(i*step), i);
      }
    error = read(pConfigMaster->fd_lv2, (uint8_t *)pWriteSenseData, data_size);
    if (error < 0)
      {
	syslog(LOG_ERR,"\nError reading from LV2 device\n");
	free((uint8_t *)pWriteSenseData);
	exit(EXIT_FAILURE);
      }
    // Display data
    syslog(LOG_NOTICE, "BOX_TEST:  sense_data for X (local loop):");
    for (i = 0; i < loop_count; i++)
      {
	syslog(LOG_NOTICE,"   xpoint[%d]=%x;sense_data=%x",
	       i,pWriteSenseData[i].point, pWriteSenseData[i].sense_val);
      }
    // Sense-Y (loop here), driver does single point sense-operation
    for (i = 0; i < loop_count; i++)
      {
	do_write_sense_one_y(inputY+(i*step), i);
      }
    error = read(pConfigMaster->fd_lv2, (uint8_t *)pWriteSenseData, data_size);
    if (error < 0)
      {
	syslog(LOG_ERR,"\nError reading from LV2 device\n");
	free((uint8_t *)pWriteSenseData);
	exit(EXIT_FAILURE);
      }
    // Display data
    syslog(LOG_NOTICE, "BOX_TEST:  sense_data for Y (local loop):");
    for (i = 0; i < loop_count; i++)
      {
	syslog(LOG_NOTICE,"   ypoint[%d]=%x;sense_data=%x",
	       i,pWriteSenseData[i].point, pWriteSenseData[i].sense_val);
      }
    free((uint8_t *)pWriteSenseData);
    exit(EXIT_SUCCESS);
}
